# Notes on the Creation of the Game “Peace Be with You”

## The Physics Subsystem
Physics engines are generally divided into two separate and simultaneously essential components: the “broad phase” and the “narrow phase”. During the broad phase, the engine determines which bodies could possibly be colliding (checking each object against one another is completely impractical; a thousand objects in a scene will result in a million collision checks per frame). The narrow phase, by contrast, is determining how to resolve the collisions, which usually involves moving the objects in question and changing their velocities in accordance with physical laws.
My broad phase consists of three major optimizations: first, I stored the movable and unmovable objects (scenery, etc.) separately, ensuring that I wouldn’t have to check collisions between objects that couldn’t move in the first place. Second, I created an array of the moveable objects that were actually moving at a given time, again to reduce the potential collisions. This part was trickier than the first, simply because switching between an object’s “stopped” and “moving” state introduced a number of bugs. However, it ended up working out quite well in the end. Lastly, I divided all the moving objects into a grid so that the engine would only have to check an object’s adjacent cells for collisions. All in all, I’m quite happy with what I’ve managed to do with the broad phase.
The narrow phase, however, is appalling. Whilst researching how to implement my engine, I make some interpretational mistakes and ended up simply creating a box around each object and checking collisions with that. This was a terrible plan because the resolution of boxes sucks (the player can’t even go under trees because it would collide with the box), and the documentation on how the resolve collisions between two three dimensional, oriented boxes is incredibly scarce. The result was that I spent an incredible amount of time implemented a system that didn’t really work at what it’s supposed to do, and, even if it did, it still wouldn’t have been a sufficient system. In retrospect, I recognize that I should have gone with a recursive bounding object. A sphere tree is a classic example: While the 3d mesh is being exported, a script would run and determine a bounding sphere around the object, then divide the object into two and determine bounding spheres around both halves. And so on and so forth. During the narrow phase, the physics engine checks collisions against the two largest spheres, and, if a collision is found, checks collisions between the closest of the smaller spheres. It continues this process until it finds (or fails to find) a collision between the smallest of the spheres. The whole process is incredibly efficient, relatively easy to implement, and has potentially great resolution. Alas, I didn’t  discover this solution until recently, and I don’t think it would be wise to spend a great deal more time with the physics engine at this point. But at least I learned, and I will be sure to implement a tree-based narrow phase after I give my presentation.

## The Graphics Subsystem
The fundamental premise for my graphics engine is simplicity: big companies hire teams of hundreds or even thousands of graphics programmers for this sort of task, so obviously much of the really high-end stuff is completely out of my reach. Nonetheless I think I can manage to create something beautiful by trying a non-photorealistic aesthetic, in this case toon shading (though I tried for a about a week to produce a painted feel to little avail). Toon shading involves two simple steps: 1) quantify lighting computations so that there’s a distinct line between light and dark, and 2) draw lines at an object’s edge. There are many potential methods for the second procedure, but the one I used was to simply perform an edge-detection filter over the values of the scene’s normals, as the normal values would be discontinuous at the edges. I also ended up multiplying this value by the depth so that far-off objects would be less likely to set off the silhouette detection (so that distant features wouldn’t be entirely black). The aforementioned lighting computations, moreover, are currently incredibly simple; objects cannot, alas, cast shadows onto other objects at this point development. Shadows are perhaps the most annoying and hard-to-perfect aspects of graphics programming and involve rendering the entire scene from the point of view of each light. Though I certainly intend to add them after my capstone is over per se, I simply wasn’t able to get around to them yet.
The main interesting feature of the graphics engine is the custom file format. Being the gung-ho developer I am, I didn’t want to use someone else’s FBX or COLLADA mesh loader, so I created the PMF (Peace Model Format) specification to store all my data. I utilized the (surprisingly well-documented) Blender Python interface to export my models, which was a pretty straightforward task until I delved into skeletal animation. Blender stores the skeleton and keyframe data quite strangely, and my script invokes some incredibly convoluted and cryptic linear algebra (produced by trial and error rather than linear algebra prowess) to make sense of it all. I finally got the animation system working at the end of the summer, and oh, what a joyous moment that was!
Lastly, the graphics system uses the same data structures as the physics for optimization. In order not to render objects unnecessarily, the engine checks every potentially renderable object against the camera’s view frustum (the borders of everything the camera can see). When doing so with the static (unmoving) objects, the engine makes use of the same quadtree used by the physics engine to check if dynamic objects collide with static objects. A quadtree is a simple yet effective structure that begins as a box divided into four smaller boxes, which is turn are divided likewise, ad infinitum (or, more realistically, ad whatever number you like). This structure helps rendering performance by giving many objects an easy-out: when the engine determines that a large box isn’t visible, it doesn’t need to check any of its sub-boxes or associated objects, thus saving potentially hundreds of checks. A similar optimization is performed by the physics engine.

## Terrain Generation
For all the complexity of terrain generation, the process boils down to something rather simple: given a 2D position as an input, determine the output height and color (or texture coordinate, or, in my case, four 8-bit integers that are interpreted as color data by my shader). And there’s tree generation. But overall not a lot of moving parts. Keeping this in mind, let’s see how my algorithm works.
The process is begun by creating a coarse grid of biomes and associated data. When determining that height and color data at each point, the generator consults the four biomes closest to each point, and, for each of them, determines the correct height and color and interpolates between them. Of course, this algorithm completely unmodified would produce an obvious array of unnaturally square-shaped biomes, so the point is offset by Perlin noise (I’m getting to that) before consulting the biomes, resulting in a more wavy look to the grid. It’s still obviously a grid if you look close enough, but it’s not terrible.
But how does one determine the data once we have biomes? The answer lies almost entirely in clever use of Perlin noise. Perlin noise, created by our good friend Ken Perlin in 1983 for the movie Tron, is a unique function (also, interestingly, based on interpolation from an underlying grid) that’s continuous and possesses a continuous derivative (meaning that it looks smooth) but nevertheless results in unpredictable values between -1 and 1. The function itself looks remarkably like rolling hills, so the simplest terrain generation would just use the function and nothing else. Mine isn’t quite that simplistic, but Perlin noise is the basis of basically every detail. The sharp rocks on mountains, for instance, are created by passing the Perlin function through the arrow-shaped absolute value function, and deserts are formed by stretching the function in a particular direction, resulting in what looks like sand dunes that have been swept by the wind in that direction.
The last component of the terrain generation was trees. The location and type of tree is largely determined by, again, Perlin noise, and I tried to model a variety of trees to make it all interesting. In keeping with my cartoony style, I didn’t even try to give the illusion of individual leaves on trees and instead made them simply voluminous. After creating common trees like Pine and Elm, I quickly began to go for the more fun and interesting species such as the exotic Baobab or the pretty Dogwood. I intend to continue making even stranger trees in the future, as I now recognize that making terrain fun is considerably more valuable than making it realistic. Such is the philosophy for my entire game, at least in theory (I imagine that I would have something much more unique and refined had I kept this is the forefront my mind throughout development).
